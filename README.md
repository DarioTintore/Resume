The following resume has the objective of expressing the main topics of my studies and the exams I challenged during my career

| Exam | Description |
| --- | --- |
| English language | An exam about the English language |
| Mathematical analysis | Elements of set theory. Numerical sets: natural numbers; whole numbers; the principle of induction; rational numbers; real numbers; real functions of a real variable and their Cartesian representation; invertible functions and monotone functions; the elementary functions. Inferior and upper bound of sets and functions. Sequences and their limits. Function limits and continuous functions. Continuous functions in an interval. Derivatives. Maximums and minimums. Criteria of monotonicity. Convex and concave functions. Taylor's formula and applications. Newton's method. Riemann integral : definition and main properties. Integrability of continuous functions. Indefinite integrals. Fundamental theorem of integral calculus. Fundamental formula of integral calculus. Number series.  |
| Physics | Elements of Mechanics and Applications: Introduction to the scientific method. Material point kinematics. Principles of dynamics of the material point. Energy and work. System dynamics. Rigid body. Gravitation. 2. Elements of Thermodynamics: Thermodynamic systems. First law of thermodynamics. The second law of thermodynamics.|
| Geometry | Basic knowledge of the theory of vector spaces over a field, with particular regard to the case of finite-dimensional real spaces. Basic knowledge of matrix calculus and of the links between matrices and linear transformations. Theory of linear systems. Calculation of the eigenvalues and eigenvectors of a linear operator and the diagonalization problem. Euclidean three-dimensional plane and space, Cartesian references and coordinates and use of the language and methods of linear algebra for solving geometric problems. Isometries and movements of the plane and of space.| 
| Algebra | Intuitive logic, elementary introduction to predicate calculus. Language of set theory, applications and comparison between sets. Combinatorial calculus, factorials, binomial coefficients. Binary relations: equivalences and partitions; orderings, well ordering of natural numbers and the principle of induction; introduction to graphs and trees. Algebraic operations and structures. Semigroups, monoids, groups, rings, fields. Stable parts, substructures. Homomorphisms and quotient structures. Lattices, Boolean algebras, Boolean rings. Lattices as particular ordered sets and as algebraic structures. Sublattices, isomorphisms. Connections between lattices, algebras and Boolean rings. Arithmetic. The Z ring of integers, the fundamental theorem of arithmetic, the Euclidean algorithm of successive divisions. Congruences in Z, the rings of the remainder classes, modular arithmetic. Linear congruential equations. Polynomials. The ring of indeterminate polynomials, division between polynomials. Polynomial applications, roots of a polynomial, Ruffini's theorem and its consequences. Irreducible polynomials; factorization of polynomials with coefficients in a field. |
| Programming I | Introduction to the concept of algorithm. Representation of data and instructions. Top down algorithm and its implementation. Control constructs: sequence, iteration and selection. Functions and procedural abstraction. Parameter passing. ADT concept. ADT Arrays and Strings. Text files. Search algorithms for elements in arrays. Element search algorithms in ordered arrays (binary search). Matrix calculation algorithms.ADT records. The derived data types. The recursion. Usefulness and power of recursion in some significant cases. Pointers and dynamic variables. ADT linked list; stacks; queue. Main algorithms for their management. Introduction to the C language. Software documentation| |Computer Architecture | Digital representations of data. Arithmetic operations and overflows. Boolean algebra, Boolean functions, combinatorial circuits and logic gates. Minimization of boolean functions. Multiplexers and decoders. Timing elements. Elementary sequential circuits: latches and flip-flops. Mealy and Moore machines: analysis and synthesis. Adder circuits and ALUs. ARM architecture: hardware elements, instruction format, internal architecture. Programming in ARM assemblies. Connections with the constructs of the C language. Introduction to cache memories. Performance analysis of cached systems. Introduction to the concept of virtual memory. Address translation. Single-cycle, multi-cycle and pipeline-based architectures. |
|Software Architecture | Digital representations of data. Arithmetic operations and overflows. Boolean algebra, Boolean functions, combinatorial circuits and logic gates. Minimization of boolean functions. Multiplexers and decoders. Timing elements. Elementary sequential circuits: latches and flip-flops. Mealy and Moore machines: analysis and synthesis. Adder circuits and ALUs. ARM architecture: hardware elements, instruction format, internal architecture. Programming in ARM assemblies. Connections with the constructs of the C language. Introduction to cache memories. Performance analysis of cached systems. Introduction to the concept of virtual memory. Address translation. Single-cycle, multi-cycle and pipeline-based architectures. | 
| Programming II | Advanced programming in C language, with projects | 
| Elements of theoretical computer science | Finite automata and sequential machines. Non-deterministic automata. regular languages. Regular expressions. Pumping lemma for regular languages. Context-independent grammars and languages. Chomski normal forms. Stacked automata and non-determinism. Correspondence between automata and grammars. Pumping lemma for context-independent languages. Chomsky's hierarchy. The concepts of algorithm, computable and partially computable function. Recursive primitive functions. Minimization. Recursive partial functions. Goedel numbers. Universal machine. Church-Turing thesis. Decision and enumeration problems. Undecidability. Recursive and recursively countable sets. Turing machine and undecidability, Computational complexity: basic notions | 
| Numerical calculus | Computational approach to solving a problem. Sources of error. Error analysis: Forward and backward. IEEE standard arithmetic. Stability of a numerical algorithm. Conditioning a mathematical problem. Conditioning index. Matrix calculus: direct methods for filled and structured matrices. Gauss elimination method. LU factorization algorithm. Stability of the Gauss elimination algorithm, pivoting strategies. Laboratory activities | 
| Programming Languages | Introduction to programming languages. Background. Recall of the theoretical computer science elements relevant to the course. Introduction to programming paradigms. Compiling and interpreting languages. Run-time support and memory management. Parameter passing mode. Data structuring and type checking. Elementary and user defined types. Encapsulation: abstract data types, modules, classes. Type systems in object-oriented languages: subtypes and inheritance; compatibility between types. Java: Control constructs and type system in detail. Parametric types (generic programming). Computation structuring: exception handling. Memory management in Java (including constructors, strings, garbage collection, and non-local environment management in the presence of inner classes). Parallelism in Java. Basic functional constructs, with examples in ML or in Python| 
| Laboratory of algorithms and data structures | abstract data types such as Lists, Stacks, Trees and an overview of Containers. The design of basic libraries for Binary Search Trees and Priority Queues, which are independent of the type of data they contain (generic data structures), will be dealt with below. Their possible implementations will be illustrated, also in relation to the Standard Libraries. Subsequently, the representation and implementation of graphs and the associated visit techniques will be systematically dealt with. Furthermore, some algorithms that operate on weighted graphs will be introduced and implemented, such as the Dijkstra algorithm, the Bellman-Ford algorithm and heuristic visit techniques, in particular the A* algorithm. In this context, the general goal is to design and implement algorithms and, more generally, libraries that operate as independent as possible from the actual data structure employed.| 
| Computer networks | Introduction to computer networks - Aims, applications, historical evolution, characteristics and layered structure. • The ISO model • The physical level - Electrical and optical transmission media. Signal encoding and decoding. Multiplexing techniques. Elements of Structured Cabling. Copper and fiber networks. Repeaters. The Data Link layer - The IEEE 802 reference model. The Ethernet network and the IEEE 802.3 standard: CSMA/CD access method. Active devices: bridge, L3 switch. The 802.11 standard: CSMA/CA access method. The network layer - The protocols of the TCP/IP suite. Repeaters, bridges, L3 switches, routers, gateways). Routing techniques, router architecture, routing algorithms. The transport layer - Services provided, transport layer addresses, sockets. UDP and TCP protocols. Application layer: Network Applications: Domain Name Server (DNS). Application layer protocols: SMTP, POP3, IMAP, SNMP, TELNET, FTP, TFTP, DHCP, NAT.Design of a computer network. The design of a LAN and WAN network. Network security: mail security: SSL, TSL; in authentication: 802.1X, EAP; in interactive sessions: SSH. 4| 
|Operating Systems I | Introduction to Operating Systems: Definitions of structures, architectures and components. Process Management: Process concepts, operations, and communications; Definitions of Threads; CPU management, Scheduling criteria and algorithms and Algorithms evaluation. Scheduling for real-time processing systems. Process synchronization; Critical section problem; Synchronization architectures; Traffic lights; Typical sync issues; critical regions; Monitors. Process Stall: Detection and recovery from deadlock situations. Memory management: Process rotation, contiguous memory allocation; Pagination; Segmentation. Virtual memory, definitions of paging and segmentation. Interface and implementation of the file system, Concept of files, methods of access, sharing and protection of files. Directory implementation, allocation methods, free space management, efficiency and performance. I/O systems: I/O architectures and devices; I/O interface for applications; Core I/O subsystem; Transformation of I/O requests into device operations; Performance. Secondary and tertiary storage, disk structure, disk scheduling, disk drive management, rotation area management; RAID structures; Connecting disks; Tertiary storage facilities. Overview of distributed architectures concerning aspects of structures, protection and safety.| 
|Algorithms and Data structures | Introduction to the calculation of the computational complexity of algorithms: asymptotic notation; calculation of the execution time of iterative algorithms; calculation of the running time of recursive algorithms, methods of solving recurrence equations. Complexity analysis of the main sorting algorithms: insertion sort, selection sort, merge sort, heap sort, quick sort. Elementary data structures and fundamental algorithms: heaps, priority queues, stacks, bulleted lists, trees. Binary search trees, balanced trees: search algorithms, insert, delete in binary search trees, AVL trees and Red and Black trees. Direct Access Tables and Hash Tables. Representation of graphs and weighted graphs, graph traversal algorithms: breadth-first (BFS) and depth-first (DFS) search algorithms. Applications of graph visits: shortest paths in unweighted graphs, verification of the acyclicity of a directed graph, topological orderings of acyclic graphs, strongly connected components. Problems on weighted graphs: minimal spanning tree, shortest paths on weighted graphs.|
|Database I| Systems architecture for database management. Conceptual design of a database, data model (described by UML Class Diagram) and constraints. Conceptual design documentation. The relational data model and logical data design. Relational algebra for querying relational databases.The SQL99 standard for: data definition, the definition of domain, ennuple, intra-relational and inter-relational constraints;querying data and defining views;data updating;metadata update;The definition of indices.Introduction to database programming techniques:Approach based on database programming language;SQL function call based approach to Java programming (JDBC);Triggers;Stored procedures;Dynamic SQL.Security aspects in databases: access control, resources and privileges.Overview of database server technology: transaction management.The normalization of relational databases.|
|Calculation of probabilities and statistics| The counting problem. The various definitions of probability of an event. Combinatorial Probability. Random experiment and associated sample space. The concept of independence and conditional probability. Bayes' theorem. The concept of random variable, distribution function and classification. Some notable models of random variables. Random variable function and random number generators. Extension to the multidimensional case. Moments of a random variable. Notable inequalities. Convergences and fundamental theorems. The concept of a simple random sample. Statistics; sample statistics; order stats. Samples from normal dams. Timely estimate. Estimators and related properties. Estimator construction methods. Introduction to interval estimation and hypothesis testing.|
|Software Engineering| Introduction to Software Engineering, software product concepts, software quality attributes; Requirements Engineering. Requirements analysis and specification, The Software Requirements document; UML: Activity Diagrams, Statecharts, Component Diagrams, OCL; System Design and Software Architectures (3 Levels, MVC, SOA, Cloud); Project Management, WBS, Gantt and Pert Charts; Versioning of Software Products. SVN; Verification and Validation. Review, Inspection, Levels of Testing, jUnit, Black Box and White Box Strategies, GUI Testing; Process Models. The waterfall process, Agile processes, SCRUM.|
|Economics| The first part of the course provides knowledge of the elements of Microeconomics such as individual demand, market demand, technology, the firm's production function and costs, the functioning of the market in its various forms. The second part of the course provides the knowledge of a simplified model of the functioning of an economic system through the knowledge of the main elements that characterize an economic system (the National Product, consumption, savings, investment, currency, inflation , etc.). The third part of the course provides knowledge of the functioning of a company since its establishment also through the reading and interpretation of accounting documents and will provide further enrichment of the functioning of the mechanisms that regulate the birth, development and decline of companies. During the lessons, applications and examples of the topics covered are proposed. |
|Web Technologies| Introduction to the web: HTTP protocol, three and more layered architecture, static web and dynamic web, the web as hypertext and as a graph, mark-up languages. Session tracking. Server-Side Programming: CGI; Java-based tools; basics of PHP. Client-side programming: JavaScript, stylesheets (CSS and XSL), DOM, AJAX. Web services. Introduction to web programming (bots, spiders and crawlers). Frameworks and CMSs.|
|Laboratory of Operating systems| The Unix shell: commands and programming; Shell/AWK Scripting; Low-level I/O and system calls for handling interaction with the file system; process management system calls; system calls for handling signals, pipes, and fifos; system calls for creating, managing, and synchronizing threads; Network communication. Client-server architectures; network communication primitives; TCP and UDP sockets. System calls for network programming; Creation of concurrent servers. Introduction to Android systems; The Android Studio framework; Structure of an Android project; The life cycle of an activity; Creation and management of activities; Interaction with the file system; Introduction to the use of SQLite; Internet connection; Network applications; background processing; Multi-threading; Synchronization management; Services; fragments; Receivers in the background. |
| Multimedia Information Systems | The course is divided into two parts. First part: definitions and classifications of Media and Multimedia. Management of audio/video multimedia data, from digitization to consultation of the same with particular references to the concepts of Storing, Digital Signal Processing, Compression and Streaming. Second part: Digital, Distributed and Interactive Multimedia Systems. Evaluations of complexity, control and adaptation. Presentation and user interfaces. Notes on Multimedia Information Systems with reference to the relationship between Multimedia Databases and the Web. Localization Systems, GPS, Fingerprinting and Inertial Measurement System| 
